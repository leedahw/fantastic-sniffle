<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>ZIM - Code Creativity</title>
    <script src="https://zimjs.org/cdn/1.3.2/createjs.js"></script>
    <script src="https://zimjs.org/cdn/cat/03/zim.js"></script>
    <script src="https://zimjs.org/cdn/Box2dWeb-2.1.a.3.min.js"></script>
    <script src="https://zimjs.org/cdn/physics_2.1"></script>
    <script>
      // https://zimjs.com - JavaScript Canvas Framework - Code Creativity!

      const frame = new Frame("fit", 1024, 1000, light, dark); //note change to 1000
      frame.on("ready", () => {
        const stage = frame.stage;
        let stageW = frame.width;
        let stageH = frame.height;

        // put your code here
        const physics = new Physics(0);
        // physics.remove(physics.borderTop); //remove border which is blocking/catching olives above canvas
        physics.drag();
        //physics.debug();
        
        const magnetism = 5; //higher number increases how fast magnetism works.
        const orbFriction = 3; //friction of ball on canvas. how quickly its force will dissapate
        const orbMagneticField = 100; //the size of the magnetic field aread around each side(positive & negative) of the orb
        const orbPolarization = 50; //best range [0-20]distance between the negative and positive poles inside the orbs

        class Orb {
          constructor(x, y,r, magneticField, magnetism, friction) {

            //Draw White cirlce
            const orbLarge = (this.orbLarge = new Circle({
              radius: r,
              color: white,
              //percent: 50
            }).loc(x, y).addPhysics({friction: 2}).outline());


            //Draw Magnets
            var magnetRadius = r/5;
            var magnetPolarization = r-magnetRadius;

            //Array to hold Positive Magnets
            const positiveMagnets = this.positiveMagnets = [
              (new Circle({radius: magnetRadius,color: black}).loc(x-(r/2), y-(r/2)).addPhysics({friction: 2})), 
              (new Circle({radius: magnetRadius,color: black}).loc(x-magnetPolarization, y ).addPhysics({friction: 2})),
              (new Circle({radius: magnetRadius,color: black}).loc(x-(r/2), y+(r/2)).addPhysics({friction: 2}))
            ]

            //Array to hold Negative Magnets
            const negativeMagnets = this.negativeMagnets = [
              (new Circle({radius: magnetRadius,color: red}).loc(x+(r/2), y-(r/2)).addPhysics({friction: 2})), 
              (new Circle({radius: magnetRadius,color: red}).loc(x+magnetPolarization, y ).addPhysics({friction: 2})),
              (new Circle({radius: magnetRadius,color: red}).loc(x+(r/2), y+(r/2)).addPhysics({friction: 2}))
            ]

            
            //magnetic field for each circle. multiplies magnetic field for magnets in the middle 
            const variedMagneticField = this.variedMagneticField = [magneticField*.2, magneticField*.7, magneticField*.2];

            //magnetic pull for each circle
            const variedMagnetism = this.variedMagnetism = [magnetism*1,magnetism*1.2, magnetism*1];

            // const positiveSide = (this.positiveSide = new Circle({
            //   radius: magnetRadius,
            //   color: black,
            //   //percent: 50
            // })
            //   //.pos(600, 500)
            //   //.rot(180)
            //   .loc(x-magnetPolarization , y)
            //   .addPhysics({friction: 2}).outline());

            // const negativeSide = (this.negativeSide = new Circle({
            //   radius: magnetRadius,
            //   color: red,
            //   //percent: 50
            // })
            //   // .pos(0, 300)
            //   .loc(x+magnetPolarization, y)
            //   .addPhysics({friction: 2}).outline());




            //Joining Physics join all the positive and negative circles in the positve and negative array into the orb cricle.
            // for(i=0; i < 3; i++ ){
            //   physics.join(this.positiveMagnets[i],orbLarge);
            //   physics.join(this.negativeMagnets[i],orbLarge);
        
            // }

            physics.join(positiveMagnets[0],orbLarge);
            physics.join(negativeMagnets[0],orbLarge);
            physics.join(positiveMagnets[1],orbLarge);
            physics.join(negativeMagnets[1],orbLarge);
            physics.join(positiveMagnets[2],orbLarge);
            physics.join(negativeMagnets[2],orbLarge);    
            
          }
        } //end of class


        const orbsArray = [];

        for (i=0; i < 5; i++ ) {

          var randX = rand(0, stageW, true, false); //using ZIM random function to get a random integer between 0 and stage Width.  
          var randY = rand(0, stageH, true, false); //using ZIM random function to get a random integer between 0 and stage Height.
          
          orbsArray.push(new Orb(randX, randY, 100,orbMagneticField ,magnetism));

          // const thingie = new StickIt(stageW / 2 + spacing * -2, y + 500);
          // const thingie2 = new StickIt(stageW / 2 + spacing * -2, y);


        }

        zog(orbsArray);
        //zog(orbsArray[0].negativeSide.physics);
        
        //zog(thingie.positiveSide.hitTestCircles(thingie2.negativeSide));

        // orbsArray[0].negativeSide.contact(orbsArray[0].positiveSide.physics, orbsArray[0].negativeSide.physics);
          
        
        // if (orbsArray[0].negativeSide.contact()) zog("contact on orb " + 0 )

        Ticker.add(() => {

          
          //select an orb to perform hit test/attraction
          for (i=0; i < orbsArray.length; i++){
            
            orbsArray[i].orbLarge.outline();

            //for all the positve magnetic circles of attraction
            for (p=0; p < 3; p++){

              //loop through all the other orbs
              for (otherOrb=0; otherOrb < orbsArray.length; otherOrb++){

                

                //for all the positive maggetic circles of the other orb
                for (otherP=0; otherP < 3; otherP++){
              

                //zog("magnetic field for orb: " + i + "= "+ orbsArray[i].variedMagneticField[m]);
                //zog("magnetic field for otherOrb : " + otherOrb + "= "+ orbsArray[otherOrb].variedMagneticField[m]);

                  if (orbsArray[i].positiveMagnets[p].hitTestCircles(orbsArray[otherOrb].negativeMagnets[otherP], orbsArray[i].variedMagneticField[p])) {
                    // zog("attracting orb: " + i + " to orb: " + j);

                      // zog("attracting orb: " + i +"at innermagnet: "+ p + "to otherOrb: "+ otherOrb + "at innermagnet: "+ otherP + "at the current magnetism of" + orbsArray[i].variedMagneticField[p]);

                      //apply force to the other orb that was hit
                      orbsArray[i].orbLarge.force(
                          (orbsArray[otherOrb].orbLarge.x - orbsArray[i].orbLarge.x)* orbsArray[i].variedMagnetism[p],
                          (orbsArray[otherOrb].orbLarge.y - orbsArray[i].orbLarge.y)* orbsArray[i].variedMagnetism[p]
                          );

                      // zog("attracting otherOrb: " + otherOrb + "to main orb: "+ i + "at the current magnetism of" + orbsArray[otherOrb].variedMagneticField[m]);
                      //apply force to the other orb that was hit
                      orbsArray[otherOrb].orbLarge.force(
                          (orbsArray[i].orbLarge.x - orbsArray[otherOrb].orbLarge.x)* orbsArray[otherOrb].variedMagnetism[otherP],
                          (orbsArray[i].orbLarge.y - orbsArray[otherOrb].orbLarge.y)* orbsArray[otherOrb].variedMagnetism[otherP]
                      );

                  }
                  
                  if(orbsArray[i].negativeMagnets[p].hitTestCircles(orbsArray[otherOrb].negativeMagnets[otherP], orbsArray[i].variedMagneticField[p])) { 
                      //zog("repelling negativeSide-orb: " + i + " to negativeSide-orb: " + j);

                      orbsArray[i].orbLarge.force(
                        -(orbsArray[otherOrb].orbLarge.x - orbsArray[i].orbLarge.x)*orbsArray[i].variedMagnetism[p],
                        -(orbsArray[otherOrb].orbLarge.y - orbsArray[i].orbLarge.y)*orbsArray[i].variedMagnetism[p]
                       );

                      orbsArray[otherOrb].orbLarge.force(
                        -(orbsArray[i].orbLarge.x - orbsArray[otherOrb].orbLarge.x)*orbsArray[otherOrb].variedMagnetism[otherP],
                        -(orbsArray[i].orbLarge.y - orbsArray[otherOrb].orbLarge.y)*orbsArray[otherOrb].variedMagnetism[otherP]
                      );

                  }
                  
                  
                  if(orbsArray[i].positiveMagnets[p].hitTestCircles(orbsArray[otherOrb].positiveMagnets[otherP], orbsArray[i].variedMagneticField[p])) { 
                      // zog("repelling positiveSide-orb: " + i + " to positiveSide-orb: " + j);

                      orbsArray[i].orbLarge.force(
                        -(orbsArray[otherOrb].orbLarge.x - orbsArray[i].orbLarge.x)*orbsArray[i].variedMagnetism[p],
                        -(orbsArray[otherOrb].orbLarge.y - orbsArray[i].orbLarge.y)*orbsArray[i].variedMagnetism[p]
                       );

                      orbsArray[otherOrb].orbLarge.force(
                        -(orbsArray[i].orbLarge.x - orbsArray[otherOrb].orbLarge.x)*orbsArray[otherOrb].variedMagnetism[otherP],
                        -(orbsArray[i].orbLarge.y - orbsArray[otherOrb].orbLarge.y)*orbsArray[otherOrb].variedMagnetism[otherP]
                      );

                  } 
                                
                }

              } 

                stage.update();
            }
          }
         
          
        });


        stage.update();
      }); //end of ready
    </script>
    <meta name="viewport" content="width=device-width, user-scalable=no" />
  </head>
  <body></body>
</html>
