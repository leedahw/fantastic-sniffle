<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>ZIM - Code Creativity</title>
    <script src="https://zimjs.org/cdn/1.3.2/createjs.js"></script>
    <script src="https://zimjs.org/cdn/cat/03/zim.js"></script>
    <script src="https://zimjs.org/cdn/Box2dWeb-2.1.a.3.min.js"></script>
    <script src="https://zimjs.org/cdn/physics_2.1"></script>
    <script>
      // https://zimjs.com - JavaScript Canvas Framework - Code Creativity!

      const frame = new Frame("fit", 1024, 1000, light, dark); //note change to 1000
      frame.on("ready", () => {
        const stage = frame.stage;
        let stageW = frame.width;
        let stageH = frame.height;

        // put your code here
        const physics = new Physics(0);
        // physics.remove(physics.borderTop); //remove border which is blocking/catching olives above canvas
        physics.drag();
        //physics.debug();
        const orbSize = 50;
        const magnetism = 20; //higher number increases how fast orbs are attracted to each other.
  

        class Orb {
          constructor(x, y,r, magnetism) {

            //intialize Magnet variables 
            var magnetRadius = r/5;
            var keyMagnetX = r-magnetRadius;
            var magneticField = r;
            var negativeColour = red;
            var positiveColour = black;

            let onePMQuotient = (r/3)*2; //amount of pixels to adjust adjacent magnets in position 1pm/5pm & 11pm/7pm positions on each orb half
            let threePMQuotient = r/3; // amount of pixels to adjust key magnets in the 3pm/9pm position on each orb half

            //Array to hold Positive Magnets
            const positiveMagnets = this.positiveMagnets = [
              (new Circle({radius: magnetRadius,color: positiveColour}).loc(x-threePMQuotient, y-onePMQuotient).addPhysics()), 
              (new Circle({radius: magnetRadius,color: positiveColour}).loc(x-keyMagnetX, y ).addPhysics()),
              (new Circle({radius: magnetRadius,color: positiveColour}).loc(x-threePMQuotient, y+onePMQuotient).addPhysics())
            ]

            //Array to hold Negative Magnets
            const negativeMagnets = this.negativeMagnets = [
              (new Circle({radius: magnetRadius,color: negativeColour}).loc(x+threePMQuotient, y-onePMQuotient).addPhysics()), 
              (new Circle({radius: magnetRadius,color: negativeColour}).loc(x+keyMagnetX, y ).addPhysics()),
              (new Circle({radius: magnetRadius,color: negativeColour}).loc(x+threePMQuotient, y+onePMQuotient).addPhysics())
            ]
            
            //magnetic field for each circle. multiplies magnetic field for magnets in the middle 
            const variedMagneticField = this.variedMagneticField = [magneticField*.15, magneticField*.2, magneticField*.15];

            //magnetic pull for each circle
            const variedMagnetism = this.variedMagnetism = [magnetism*1,magnetism*1.2, magnetism*1];


            //Draw White cirlce for orb
            const orbLarge = (this.orbLarge = new Circle({
              radius: r,
              color: "rgba(255,255,255,0.5)",
              //percent: 50
            }).loc(x, y).addPhysics({friction: 100, linear: 3, angular: 5, density:10}).outline());

            // linear - (default .5) - linear damping which slows the movement - set to 0 for no damping
            // angular - (default .5) - angular damping which slows the rotation - set to 0 for no damping
            // density - (default 1) - the density that can affect what happens with collisions

            //Joining Physics join all the positive and negative circles in the positve and negative array into the orb cricle.
            physics.join(positiveMagnets[0],orbLarge);
            physics.join(negativeMagnets[0],orbLarge);
            physics.join(positiveMagnets[1],orbLarge);
            physics.join(negativeMagnets[1],orbLarge);
            physics.join(positiveMagnets[2],orbLarge);
            physics.join(negativeMagnets[2],orbLarge);    
          }
        } //end of class


        const orbsArray = [];

        for (i=0; i < 10; i++ ) {

          var randX = rand(0, stageW, true, false); //using ZIM random function to get a random integer between 0 and stage Width.  
          var randY = rand(0, stageH, true, false); //using ZIM random function to get a random integer between 0 and stage Height.
          
          orbsArray.push(new Orb(randX, randY, orbSize ,magnetism));

        }

        zog(orbsArray);
        //zog(orbsArray[0].negativeSide.physics);
        
        //zog(thingie.positiveSide.hitTestCircles(thingie2.negativeSide));

        // orbsArray[0].negativeSide.contact(orbsArray[0].positiveSide.physics, orbsArray[0].negativeSide.physics);
          
        
        // if (orbsArray[0].negativeSide.contact()) zog("contact on orb " + 0 )

        Ticker.add(() => {
          
          //select an orb to perform hit test/attraction
          for (i=0; i < orbsArray.length; i++){
            
            orbsArray[i].orbLarge.outline();

            //for all the positve magnetic circles of attraction
            for (p=0; p < 3; p++){

              //loop through all the other orbs
              for (otherOrb=0; otherOrb < orbsArray.length; otherOrb++){

                

                //for all the positive maggetic circles of the other orb
                for (otherP=0; otherP < 3; otherP++){
              

                //zog("magnetic field for orb: " + i + "= "+ orbsArray[i].variedMagneticField[m]);
                //zog("magnetic field for otherOrb : " + otherOrb + "= "+ orbsArray[otherOrb].variedMagneticField[m]);

                  if (orbsArray[i].positiveMagnets[p].hitTestCircles(orbsArray[otherOrb].negativeMagnets[otherP], orbsArray[i].variedMagneticField[p])) {
                    // zog("attracting orb: " + i + " to orb: " + j);

                      // zog("attracting orb: " + i +"at innermagnet: "+ p + "to otherOrb: "+ otherOrb + "at innermagnet: "+ otherP + "at the current magnetism of" + orbsArray[i].variedMagneticField[p]);

                    //apply force to the other orb that was hit
                    orbsArray[i].orbLarge.force(
                        (orbsArray[otherOrb].orbLarge.x - orbsArray[i].orbLarge.x)* orbsArray[i].variedMagnetism[p],
                        (orbsArray[otherOrb].orbLarge.y - orbsArray[i].orbLarge.y)* orbsArray[i].variedMagnetism[p]
                        );

                    // zog("attracting otherOrb: " + otherOrb + "to main orb: "+ i + "at the current magnetism of" + orbsArray[otherOrb].variedMagneticField[m]);
                    //apply force to the other orb that was hit
                    orbsArray[otherOrb].orbLarge.force(
                        (orbsArray[i].orbLarge.x - orbsArray[otherOrb].orbLarge.x)* orbsArray[otherOrb].variedMagnetism[otherP],
                        (orbsArray[i].orbLarge.y - orbsArray[otherOrb].orbLarge.y)* orbsArray[otherOrb].variedMagnetism[otherP]
                    );

                  }
                  
                  if(orbsArray[i].negativeMagnets[p].hitTestCircles(orbsArray[otherOrb].negativeMagnets[otherP], orbsArray[i].variedMagneticField[p])) { 
                      //zog("repelling negativeSide-orb: " + i + " to negativeSide-orb: " + j);

                      orbsArray[i].orbLarge.force(
                        -(orbsArray[otherOrb].orbLarge.x - orbsArray[i].orbLarge.x)*orbsArray[i].variedMagnetism[p],
                        -(orbsArray[otherOrb].orbLarge.y - orbsArray[i].orbLarge.y)*orbsArray[i].variedMagnetism[p]
                       );

                      orbsArray[otherOrb].orbLarge.force(
                        -(orbsArray[i].orbLarge.x - orbsArray[otherOrb].orbLarge.x)*orbsArray[otherOrb].variedMagnetism[otherP],
                        -(orbsArray[i].orbLarge.y - orbsArray[otherOrb].orbLarge.y)*orbsArray[otherOrb].variedMagnetism[otherP]
                      );

                  }
                  
                  
                  if(orbsArray[i].positiveMagnets[p].hitTestCircles(orbsArray[otherOrb].positiveMagnets[otherP], orbsArray[i].variedMagneticField[p])) { 
                      // zog("repelling positiveSide-orb: " + i + " to positiveSide-orb: " + j);

                      orbsArray[i].orbLarge.force(
                        -(orbsArray[otherOrb].orbLarge.x - orbsArray[i].orbLarge.x)*orbsArray[i].variedMagnetism[p],
                        -(orbsArray[otherOrb].orbLarge.y - orbsArray[i].orbLarge.y)*orbsArray[i].variedMagnetism[p]
                       );

                      orbsArray[otherOrb].orbLarge.force(
                        -(orbsArray[i].orbLarge.x - orbsArray[otherOrb].orbLarge.x)*orbsArray[otherOrb].variedMagnetism[otherP],
                        -(orbsArray[i].orbLarge.y - orbsArray[otherOrb].orbLarge.y)*orbsArray[otherOrb].variedMagnetism[otherP]
                      );

                  } 
                                
                }

              } 

                stage.update();
            }
          }
         
          
        });


        stage.update();
      }); //end of ready
    </script>
    <meta name="viewport" content="width=device-width, user-scalable=no" />
  </head>
  <body></body>
</html>
